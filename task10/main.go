package main

import (
	"container/list"
	"fmt"
)

// Pool хранит в себе сгруппированные значения температуры.
type Pool struct {
	// Будем сохранять группы в виде связанных списков для большей эффективности добавления новых
	// значений. Каждая группа будет располагаться в карте по индексу, который кратен 10.
	data map[int]*list.List
}

func NewPool() *Pool {
	return &Pool{
		data: map[int]*list.List{},
	}
}

func (p *Pool) hash(v float64) int {
	// Считаем индекс в карте для группы, в которую нужно поместить элемент v.
	//
	// Итоговый индекс будет кратен 10, при этом будет по модулю меньше самого значения,
	// причём разница будет не больше 10.
	//
	// Можно назвать это "округлением" в меньшую по модулю сторону до ближайшего значения, кратного 10.
	return int(v) / 10 * 10
}

// Add добавляет новый элемент в подходящую группу.
func (p *Pool) Add(v float64) {
	// Считаем, в какой группе будет находиться новый элемент.
	h := p.hash(v)

	// Создаём новую группу, если её ещё нет.
	if _, ok := p.data[h]; !ok {
		p.data[h] = list.New()
	}

	// Добавляем значение в группу.
	p.data[h].PushBack(v)
}

// Print выводит всё содержимое по группам.
func (p *Pool) Print() {
	for threshold, values := range p.data {
		// Выводим само число, а также квадратную скобку.
		fmt.Printf("%+5d \t[", threshold)

		// После осуществляем обход связного списка.
		// Выводим каждое следующее число, после чего добавляем запятую или закрывающую
		// квадратную скобку, если дальше нет элементов.
		for v := values.Front(); v != nil; {
			delimiter := "]\n"
			if v.Next() != nil {
				delimiter = ", "
			}

			fmt.Printf("%.1f%s", v.Value, delimiter)
			v = v.Next()
		}
	}
}

func main() {
	pool := NewPool()

	// Добавляем все значения из задания.
	values := []float64{-25.4, -27.0, 13.0, 19.0, 15.5, 24.5, -21.0, 32.5}
	for _, v := range values {
		pool.Add(v)
	}

	// Выводим сгруппированные значения.
	pool.Print()
}
