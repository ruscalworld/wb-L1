package main

import (
	"fmt"
	"time"
)

func Sleep(duration time.Duration) {
	// Просто попросим Go сообщить нам, когда пройдёт нужное количество времени.
	// А пока что заблокируем текущую горутину чтением из канала, куда мы получим
	// сообщение, когда пройдёт нужное количество времени.
	_ = <-time.After(duration)

	// Так мы достигли поведения, схожего с функцией Sleep, достаточно простым способом.
	// Полагаю, что иным способом, позволяющим обойтись без таймеров, может быть
	// бесконечный цикл, выход их которого производится только при достижении определённой
	// отметки времени, например:
	//
	// 	deadline := time.Now().Add(duration)
	// 	for time.Now().UnixMilli() < deadline.UnixMilli() {}
	//
	// Однако такое решение будет задействовать всё процессорное время на протяжении всего
	// периода ожидания.

	// Более правильным решением в случае, если действительно потребовалось написать свою
	// функцию sleep, будет переход на более низкоуровневый язык программирования...
}

func main() {
	fmt.Println(time.Now().Unix())
	Sleep(2 * time.Second)
	fmt.Println(time.Now().Unix())
}
